import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from matplotlib.cm import get_cmap
import matplotlib.colors as mcolors

def parametric_curve(s):
    """Define the parametric curve for initialization."""
    return np.array([s, np.sin(3 * np.pi * s / n)])

def compute_arc_length(s_vals, curve_func):
    """Compute cumulative arc length along the curve."""
    arc_lengths = [0]
    for i in range(1, len(s_vals)):
        ds = np.linalg.norm(curve_func(s_vals[i]) - curve_func(s_vals[i - 1]))
        arc_lengths.append(arc_lengths[-1] + ds)
    return np.array(arc_lengths)

def generate_equally_spaced_nodes(n, s_range):
    """Generate n+2 equally spaced points along a curve using arc-length parameterization."""
    s_fine = np.linspace(s_range[0], s_range[1], 1000)  # Fine sampling
    fine_curve = np.array([parametric_curve(s) for s in s_fine])
    
    # Compute arc lengths along the fine sampling
    arc_lengths = compute_arc_length(s_fine, parametric_curve)
    
    # Create interpolation functions for x and y based on arc length
    interp_x = interp1d(arc_lengths, fine_curve[:, 0], kind='linear')
    interp_y = interp1d(arc_lengths, fine_curve[:, 1], kind='linear')
    
    # Generate n+2 equally spaced arc-length positions
    equal_arc_lengths = np.linspace(0, arc_lengths[-1], n + 2)
    x_vals = interp_x(equal_arc_lengths)
    y_vals = interp_y(equal_arc_lengths)
    
    return np.column_stack((x_vals, y_vals))

def compute_bending_energy(vertices, l, alpha):
    """Compute bending energy E_bend"""
    n = len(vertices) - 2
    theta = np.zeros(n)
    for i in range(1, n + 1):
        e_prev = vertices[i] - vertices[i - 1]
        e_next = vertices[i + 1] - vertices[i]
        norm_prev = np.linalg.norm(e_prev)
        norm_next = np.linalg.norm(e_next)
        if norm_prev == 0 or norm_next == 0:
            continue  # Skip computation if vectors collapse
        cos_theta = np.dot(e_prev, e_next) / (norm_prev * norm_next)
        cos_theta = np.clip(cos_theta, -1, 1)
        theta[i - 1] = np.arccos(cos_theta)
    return alpha * np.sum((theta ** 2) / l)

def compute_forces(vertices, l, alpha):
    """Compute forces"""
    n = len(vertices)
    forces = np.zeros_like(vertices)
    for i in range(1, n-1):
        e_prev = vertices[i] - vertices[i-1]
        e_next = vertices[i+1] - vertices[i]
        norm_prev = np.linalg.norm(e_prev)
        norm_next = np.linalg.norm(e_next)
        if norm_prev == 0 or norm_next == 0:
            continue  # Avoid division by zero
        cos_theta = np.dot(e_prev, e_next) / (norm_prev * norm_next)
        cos_theta = np.clip(cos_theta, -1, 1)
        theta = np.arccos(cos_theta)
        
        if np.abs(cos_theta) < 1:
            dtheta_dx = -1 / np.sqrt(1 - cos_theta ** 2) * (e_next / norm_next - e_prev / norm_prev)
        else:
            dtheta_dx = np.zeros_like(e_prev)  # Avoid singularity
        
        forces[i] += alpha * (2 * theta / l) * dtheta_dx
    
    return -forces

def enforce_length_constraints(vertices, l, iterations=5):
    """Enforce that each segment has length l using iterative projection."""
    n = len(vertices) - 1
    for _ in range(iterations):
        for i in range(n):
            delta = vertices[i+1] - vertices[i]
            current_length = np.linalg.norm(delta)
            if current_length == 0:
                continue
            correction = (current_length - l) * (delta / current_length) / 2
            vertices[i] += correction
            vertices[i+1] -= correction

def relax_rod(vertices, l, alpha, gamma, dt, steps):
    """Simulate the rod relaxation process with explicit length constraint enforcement."""
    history = []
    edge_lengths = []

    for step in range(steps):
        if step % (steps // 10) == 0:  # Store every few steps for visualization
            history.append(vertices.copy())

        forces = compute_forces(vertices, l, alpha)
        vertices += (dt / gamma) * forces
        enforce_length_constraints(vertices, l)

        # Compute edge lengths at each timestep
        edge_lengths.append([np.linalg.norm(vertices[i + 1] - vertices[i]) for i in range(len(vertices) - 1)])
    
    return history, edge_lengths

# Parameters
n = 10  # Number of segments
l = 1.0  # Rest length of each segment
alpha = 1.0  # Bending stiffness
gamma = 1.0  # Damping coefficient
dt = 0.01  # Time step
steps = 500  # Simulation steps

# Generate rod with equal arc-length spacing
vertices = generate_equally_spaced_nodes(n, [0, n * l])

# Relax the rod 
history, edge_lengths = relax_rod(vertices, l, alpha, gamma, dt, steps)

# Display rod relaxation with color gradient
fig, ax = plt.subplots()
cmap = get_cmap("viridis")
n_steps = len(history)
norm = mcolors.Normalize(vmin=0, vmax=n_steps)
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])

for i, state in enumerate(history):
    color = cmap(i / n_steps)
    ax.plot(state[:, 0], state[:, 1], marker='o', color=color, alpha=0.8, label=f"Step {i}")

plt.xlabel("x")
plt.ylabel("y")
plt.title("Relaxation of 2D Rod with Equal Edge Lengths")
cbar = plt.colorbar(sm, ax=ax)
cbar.set_label("Timestep Index")
plt.show()

# Plot edge lengths over time
edge_lengths = np.array(edge_lengths)

plt.figure(figsize=(8, 5))
for i in range(edge_lengths.shape[1]):  # Plot each segment's length
    plt.plot(range(steps), edge_lengths[:, i], label=f"Edge {i+1}")

plt.axhline(y=l, color='k', linestyle='--', label="Target Length")
plt.xlabel("Timestep")
plt.ylabel("Edge Length")
plt.title("Edge Lengths Over Time")
plt.legend(loc='best', fontsize='small')
plt.show() 
